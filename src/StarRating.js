import { useState } from "react";
import PropTypes from "prop-types";

const containerStyle = {
  display: "flex",
  alignItems: "center",
  gap: "16px",
}; // this object will never change and it doesn't depend on anything that is in the
//  StarRating component. So we place it here completely outside of the component. So now
//  this object will not have to be generated by JS each time the StarRating component is
//  rendered. It will be created only once when the module is loaded.

// Below is style for the stars container.
const starsContainerStyle = {
  display: "flex",
};

// we want to allow the user of this StarRating component to set the maximum amount of
// stars(so, the maximum rating). So we pass a maxRating prop to the StarRating component
// and we use it in Array.from() to define length. We pass maxRating = 5 in the StarRating
// component as prop to set a default value of 5 stars in case the user does not set the
// max amount of stars. We also improve reusability with props(i.e. defining a public API
// for consumers to use it (Watch Lecture 118 - Props as a component API for better
// understanding. Also lecture 119 - Improvong reusability with props)). We do this by, for
// example passing props like color and size as we did below in StarRating component
// function and setting a default value for them and then using them inside textStyle
// object used for styling. This object is now inside component function because everytime
// style will depend on value passed. Similarly, starStyle object is inside Star component
// function. We pass in a className prop in StarRating component function in case we want
// to add some class to the component from css file. We add it to the overall container in
// the returned JSX. Also, we passed a messages prop which is an empty array by default.
// Instead of numbers for rating, we can pass in some messages and those messages will be
// displayed in place of rating. We only want to use this messages array in case there are
// some values in that array and also the number of elements in the array should be
// correct(so if we allow for a rating between 1 and 5 and we have only 3 elements in the
// array then it doesn't make a lot of sense). so we use this messages array in the
// StarRating component function where the rating is displayed. First we check if the array
// length is correct, if yes then if tempRating is used, we display message at tempRating â€“
// 1 otherwise at rating - 1. If array length is not correct, then if rating is a falsy
// value(i.e. 0) then we will display empty string(i.e.) nothing on the screen. We also
// pass a defaultRating prop in the StarRating component and we initialize the rating state
// based on that.

// The consumer might actually need the rating state of the StarRating component function
// outside of the component. We can see this in the fact that the Test component in
// index.js file requires the rating state for displaying in th UI This movie was rated X
// stars. So what the Test component needs is some state(as we can see it has movieRating
// state) and it needs to update that state whenever we update the rating state below in
// the StarRating component. So basically we want to give the consumer of this Test
// component to pass in a set function. So the consumer specifies an onSetRating handler.
// In this case what the Test component wants to pass in is the onSetRating function. So we
// specify this as a prop(receive it in the StarRating component function) and it by
// default doesn't need any defalut value. Then all we have to do is that in the
// handleRating() function, we not only set the internal Rating(internal rating is set by
// the setRating(rating) that we did in the handleRating() function) but also external
// rating by doing onSetRating(rating). With this we give the outside Test component the
// ability to get access to the internal state(rating state of the StarRating component)
// right inside the Test component.

// With propTypes, we can specify the type of value that we expect the consumer of the
// component to pass in for each of the props. For example, we can specify that the
// maxRating must be a number and nothing else. This is called type checking. If we
// really care about this, we should just use TypeScript instead of JavaScript. Here we
// use the built in porpTypes. For that we import it at the top. To do the type checking,
// we use the component and we define the propTypes property on it and then we assign
// those propTypes an object as just below(note that while importing at top, the first
// letter 'P' is capital while defining the propType property on component below, the
// first letter 'p) is small case:

StarRating.propTypes = {
  // in this object, for each of the props, we can specify a type(for this we use the
  // PropType object we imported at the top and use one of the validators that is inside
  // this PropType object, just like we did for maxRating prop below):
  maxRating: PropTypes.number,
  // now, since we did maxRating: PropTypes.number, if the consumer specifies a value
  // for this prop which is not a number, an error is generated which can be used for
  // debugging. We could also chain isRequired as maxRating: PropTypes.number.isRequired
  // which will make this maxRating prop necessary to have a value given by the consumer.
  // If no given, an error is generated.
  defaultRating: PropTypes.number,
  color: PropTypes.string,
  size: PropTypes.number,
  messages: PropTypes.array,
  className: PropTypes.string,
  onSetRating: PropTypes.func, // func stands for function. we also have bool for
  //                              boolean and object for object
};

export default function StarRating({
  maxRating = 5,
  color = "#fcc419",
  size = 48,
  className = "",
  messages = [],
  defaultRating = 0,
  onSetRating,
}) {
  const [rating, setRating] = useState(defaultRating); // this state is used because whenever
  //                            we click on one of the stars, then we want to display the
  //                            current rating in the paragraph element. We need to listen
  //                            for click event on each of the stars so we define a onRate
  //                            prop in each of the <Star /> component genereated from
  //                            Array.from() and we will later receive inside the Star
  //                            component function and pass it in OnClick prop. If we click a
  //                            star, then from staring upto that star, all stars should be
  //                            full and rest of the stars should be empty. So, in the Star
  //                            component function, we receive a full prop which will tell if
  //                            the star is full and we conditionally render the full and
  //                            empty stars based on it.

  const [tempRating, setTempRating] = useState(0); // this state is for hover because on
  //                            hover we temporarily get a rating corresponding to the star
  //                            we are hovering on and also accordingly the stars appear full
  //                            or empty. rating and full stars get fixed only on clicking.
  //                            We handle this hover event in the Star component function by
  //                            passing a handler function through onHoverIn prop and
  //                            onHoverOut prop in the Star component in Array.from() and
  //                            receive them in the Star component function and use inside a
  //                            onMouseEnter prop and also a onMouseLeave prop.

  function handleRating(rating) {
    setRating(rating); // setting internal rating of this StarRating component
    onSetRating(rating); // setting external rating of the Test component
  }

  const textStyle = {
    lineHeight: "1",
    margin: "0",
    color,
    fontSize: `${size / 1.5}px`,
  };

  return (
    <div style={containerStyle} className={className}>
      <div style={starsContainerStyle}>
        {Array.from({ length: maxRating }, (_, i) => (
          <Star
            key={i}
            onRate={() => handleRating(i + 1)}
            full={tempRating ? tempRating >= i + 1 : rating >= i + 1} // this full prop needs
            //                            to be a true or false value for conditional rendering of full
            //                            or empty stars in the Star component function. so for each
            //                            star, current rating is compared with star index + 1. If
            //                            rating >= index + 1 for a star then that star is full. Also,
            //                            on hovering, only tempRating works and when we click then
            //                            full and empty stars get fixed. So, if there is tempRating,
            //                            then it works otherwise rating works. So if we click on a
            //                            star then full and empty stars and correct rating are shown
            //                            accordingly but if we hover again then again tempRating is
            //                            there so tempRating now works and on hovering, the stars from
            //                            starting upto that star appear hovered and the rating that
            //                            should be if we click that star appear but if we stop
            //                            hovering on any star, then again the fixed full and empty
            //                            stars with the fixed rating that was done before due to click
            //                            appear again. Similarly where we display rating, we do
            //                            tempRating || rating || ""
            onHoverIn={() => setTempRating(i + 1)} // here we just have to set the tempRating
            //                                              to the rating of the current star on hover.
            onHoverOut={() => setTempRating(0)} // on hover out, we set tempRating back to
            //                                               initial value
            color={color}
            size={size}
          />
        ))}
      </div>
      <p style={textStyle}>
        {messages.length === maxRating
          ? messages[tempRating ? tempRating - 1 : rating - 1]
          : tempRating || rating || ""}
      </p>
      {/* First we check if the array length is correct, if yes then if tempRating is used,
          we display message at tempRating - 1 otherwise at rating - 1. If array length is
          not correct, then if rating is a falsy value(i.e. 0) then we will display empty
          string(i.e.) nothing on the screen */}
    </div>
  );
}

function Star({ onRate, full, onHoverIn, onHoverOut, color, size }) {
  const starStyle = {
    width: `${size}px`,
    height: `${size}px`,
    display: "block",
    cursor: "pointer",
  };

  return (
    <span
      role="button"
      style={starStyle}
      onClick={onRate}
      onMouseEnter={onHoverIn}
      onMouseLeave={onHoverOut}
    >
      {full ? (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 20 20"
          fill={color}
          stroke={color}
        >
          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
        </svg>
      ) : (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke={color}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="{2}"
            d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"
          />
        </svg>
      )}
    </span>
  );
}

/*
FULL STAR

<svg
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 20 20"
  fill="#000"
  stroke="#000"
>
  <path
    d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
  />
</svg>


EMPTY STAR

<svg
  xmlns="http://www.w3.org/2000/svg"
  fill="none"
  viewBox="0 0 24 24"
  stroke="#000"
>
  <path
    strokeLinecap="round"
    strokeLinejoin="round"
    strokeWidth="{2}"
    d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"
  />
</svg>

*/
