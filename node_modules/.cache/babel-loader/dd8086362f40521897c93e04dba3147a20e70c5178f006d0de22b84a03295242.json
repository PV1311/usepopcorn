{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\verma\\\\OneDrive\\\\Desktop\\\\Web Dev Adv\\\\React\\\\React\\\\07-usepopcorn\\\\starter\\\\src\\\\App.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst tempMovieData = [{\n  imdbID: \"tt1375666\",\n  Title: \"Inception\",\n  Year: \"2010\",\n  Poster: \"https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg\"\n}, {\n  imdbID: \"tt0133093\",\n  Title: \"The Matrix\",\n  Year: \"1999\",\n  Poster: \"https://m.media-amazon.com/images/M/MV5BNzQzOTk3OTAtNDQ0Zi00ZTVkLWI0MTEtMDllZjNkYzNjNTc4L2ltYWdlXkEyXkFqcGdeQXVyNjU0OTQ0OTY@._V1_SX300.jpg\"\n}, {\n  imdbID: \"tt6751668\",\n  Title: \"Parasite\",\n  Year: \"2019\",\n  Poster: \"https://m.media-amazon.com/images/M/MV5BYWZjMjk3ZTItODQ2ZC00NTY5LWE0ZDYtZTI3MjcwN2Q5NTVkXkEyXkFqcGdeQXVyODk4OTc3MTY@._V1_SX300.jpg\"\n}];\nconst tempWatchedData = [{\n  imdbID: \"tt1375666\",\n  Title: \"Inception\",\n  Year: \"2010\",\n  Poster: \"https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg\",\n  runtime: 148,\n  imdbRating: 8.8,\n  userRating: 10\n}, {\n  imdbID: \"tt0088763\",\n  Title: \"Back to the Future\",\n  Year: \"1985\",\n  Poster: \"https://m.media-amazon.com/images/M/MV5BZmU0M2Y1OGUtZjIxNi00ZjBkLTg1MjgtOWIyNThiZWIwYjRiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg\",\n  runtime: 116,\n  imdbRating: 8.5,\n  userRating: 9\n}];\nconst average = arr => arr.reduce((acc, cur, i, arr) => acc + cur / arr.length, 0);\nconst KEY = \"f608407f\";\nexport default function App() {\n  _s();\n  const [query, setQuery] = useState(\"\");\n  const [movies, setMovies] = useState([]);\n  const [watched, setWatched] = useState([]);\n  const [isLoading, setIsLoading] = useState(false); // now whenever movie data is still being loaded in the background, we want to instead display some loading indicator. So in case movie data loading takes time, we see a flash where there is no content. So the movie data was loading but hadn't arrived yet. So now in the mean time we want to display some loading indicator. So in order to do that we have this state which tells UI that data is still being loaded and then as soon as the data has been loaded, we want to display that data and not that indicator anymore. In our effect, right before the fetching actually starts, we setIsLoading to true.\n  const [error, setError] = useState(\"\"); // we want to display the new error message that we throw below in case an error happens while fetching data, onto the screen instead of the Loading indicator. So this state is for that. It tells currently whether we have an error or not. Here it not a boolean but truly the error message. Based on this error state, we will conditionally render the ErrorMessage component which receives a messgae prop with some message that it will then display on the screen.\n  const [selectedId, setSelectedId] = useState(null); // we need to select a movie and display some data related to it. Selecting happens on left box on dcreena nd displaying happens on right box on screen. So we create this state here in the parent component. Here we only store the id and not the entire movie object itself because the movies that we get here from the search very limited(we only get data about the title, year and the poster). On the right side we will want all kinds of details that are not included in the first search. So there would have to be another API call which will load the movie again and then we will get all the details and this movie will be fetched based on the ID that we get in the array we get when we search a movie(we can see this array by doing console.log(data.Search))\n\n  // const tempQuery = \"interstellar\";\n\n  /*\n  // BELOW IS JUST AND EXPERIMENT WITH DEPENDENCY ARRAY OF EFFECT:\n  // useEffect(function () {\n  //   console.log(\"After initial render\");\n  // }, []);\n   // useEffect(function () {\n  //   console.log(\"After every render\");\n  // });\n   // console.log(\"During render\"); // we can see that on console, first During render is logged, then After initial render, then After every render. the reason is that effects only run after the Browser paint while the render logic runs during render. So console.log(\"During render\") is executed first(so during the render of this component) and then we have After initial render and then After every render simply because After initial render appears first in the code. After it if we type any letter in the Search bar, we update the query state and hence the component is re-renered and hence consolelog(\"During render\") was executed due to which we see During render first and then After every render because the effect that logs After every render has no dependency array which means that effect is synchronized with everything and therefore it runs on every render. The effect that logs After initial render is synchronized with no variables(which is the meaning of the empty array) and therefore that effect was not executed as the component was re-rendered with the query state.\n   // BELOW IS ANOTHER EXPERIMENT WITH DEPENDENCY ARRAY OF EFFECT:\n  // useEffect(function () {\n  //   console.log(\"After initial render\");\n  // }, []);\n   // useEffect(function () {\n  //   console.log(\"After every render\");\n  // });\n   // useEffect(\n  //   function () {\n  //     console.log(\"D\");\n  //   },\n  //   [query]\n  // );\n   // console.log(\"During render\"); // now, once we type a letter in search bar, first During render is logged, then After every render and then D. Now we get D logged because then effect logging it is synchronized with the query state variable. Therefore the query just changed and the effect synchronized with state was executed and logged D.\n  */\n\n  function handleSelectMovie(id) {\n    setSelectedId(selectedId => id === selectedId ? null : id); // if we click on the same movie on left box on screen as is open on right box, we want to close movie on right box and if we select a movie different from the one open on right box then we want to open that movie on the right box\n  }\n\n  function handleCloseMovie() {\n    setSelectedId(null);\n  }\n\n  // At times of fetching data and dealing with asynchronous data, we need to assume that somethings can go wrong(like internet connection breaking while fetching data or no movie found for the search query) and therefore we also need to account for those situations by handling those errors.\n  useEffect(function () {\n    async function fetchMovies() {\n      try {\n        setIsLoading(true); // this tells UI that loadind is happening and we can then render the indicator over there. Then after everything is finished, we set isLoading state back to false as seen towards the end in the finally{} block in this function\n        setError(\"\"); // before we start fetching we also set the error to an empty string because if we do not do this and if we get an error at some point and we generate an error message on the screen(login for catching and setting error done below), then the next time we try to fetch data and display on screen, fetching will be done correctly(if no error occurs) but displaying cannot be done and still error is displayed on screen because we we never reset the error.\n\n        const res = await fetch(`http://www.omdbapi.com/?apiKey=${KEY}&s=${query}`);\n        if (!res.ok) throw new Error(\"Something went wrong with fetching movies!\"); // now in between fetching data, user's internet connection might break so app will always keep showing the Loading indicator making user beleive that data will arrive at some point. so when it happens we want to display an error message on screen. Now reacting to errors like this is not built into the fetch() function itself, we need to do it manually. Now here on the response object that we receive from the fetch() exists one ok property. So basically if the response is not ok, then we want to throw a new error. Now if we throw an error here, we need to wrap all our code into a try catch block.\n\n        const data = await res.json();\n        // console.log(data);\n\n        if (data.Response === \"False\") throw new Error(\"Movie not found !\"); // if for a query, no movie is found, then the data that comes back from this API is undefined. So we no longer have the Search property now(So we don't have data.Search). So what happens is that data.Search is being set to undefined. So now if we log the received data on cosole, we see an object with Response and Error properties. So we can use Response(which in this case is False) to check if the movie is not found and throw an Error. This if here and not anywhere else because we check it after we have received the data from API.\n\n        setMovies(data.Search);\n        // console.log(movies); // here if we try to log the movies to the console, we get an empty array as a result. This happens becuase setting state is asynchronous. So after setting state in the just above line using setMovies(), it doesn't mean that it happens immediately. So it will happen after the function has been called. so right here in console.log(movies), we have stale state. So before, movies was just an empty array which gets logged. After some time we get the correct output. Now if we do this console.log() again, we get correct output. Now, the reson for getting two outputs is because of React's strict mode. So when strict mode is active in React 18, our effects will run not only once, but twice(but only in development. So when our application is in production, this will no longer be happening). This happens so REact can identify if there are some problems in our effects.\n      } catch (err) {\n        console.error(err.message); // err.message is the string that pass into throw new Error('') as above.\n        setError(err.message); // in case of error, we set the error state to the error string that we passed above while throwing error. Now based on this error state, we will conditionally render the ErrorMessage component which receives a messgae prop with some message that it will then display on the screen.\n      } finally {\n        setIsLoading(false); // This is here because is we the error is thrown above, then the code after it in the try{} block will not be executed. So it is in this finally{} block which is always executed. Now in the returned JSX, we conditionally render the <Loader.> component if isLoading is true, but there are 2 more conditional renders with it. (Look and understand. if not understood, Watch Lecture 146 - Adding a loading state and Lecture 147 - Handling errors)\n      }\n    }\n\n    if (!query.length) {\n      setMovies([]); // here we set movies back to an empty array(so basically removing all the movies from the UI)\n      setError(\"\"); // here we reset the error back to nothing\n      return;\n    } // if we don't do this if if block, then when have no search query, we see Movie not found on screen(even on opening application) which is not really true(It is actually true because the API actually searched for a movie with an empty string but in a situation when we have no query we actually don't even want to search). Also, doing this if block, the fetchMovies function will not even be called(as called in the just below line).\n\n    fetchMovies(); // here we just call the function\n  }, [query]); // useEffects() doesn't return anything so we don't store the resuukt into any variable but instead we pass in a function and this function is then called our effect and it contains the code that we want to run as a side effect(so basically that we want to register as a side effect to be executed at a certain point in time). We also need to pass in a second argumnent which is a dependency array. We'll learn about it as we proceed further. empty array as here means that the effect that we just specified here will only run on mount. Now ew can see that there are no infinite loops or requests. So now effect is only running as the component mounts. Now, whenever we need a lot of code to handle a promise, it's a lot easier and nicer to just have an async function. However if we write async nefore the function inside useEffect() here and use await inside it, we get an ESLint warning which tells us that effect callbacks are synchronous to prevent race conditions. So basically the effect function that we placed into useEffect() cannot return a promise which is what an async function does. So instead of doing diretly like this, we create a new function and place the async function there as we did here\n\n  // // We know we should never update state in render logic.\n  // // Basic idea is to fetch some movie data as soon as this App component here mounts for the very  first time.\n  // fetch(`http://www.omdbapi.com/?apiKey=${KEY}&s=interstellar`)\n  //   .then((res) => res.json())\n  //   .then((data) => console.log(data.Search)); // Now, this data fetching that we are doing here is actually introducing a side effect into the component's render logic. So it is clearly an interaction with an outside world which should never be allowed in render logic. Now, as we see here, if insetead of logging the fetched data on console, we set state here with the fetched data, in the Network tab we can see that it is running an infinite number of requests and it never really stops. So every second, our app is firing off multiple requests to this API. This happends because setting the state here in the render logic will then immediately cause the component to re-render itself again. However, as the component is re-rendered, the function here is executed again, which in turn will fetch again, which in turn will set the movies again as well and this whole thing starts over ad over again. So this is the reason why it is really not allowed to set state in the render logic. Now, we do actually need to set the movies here but without all the problems. So for that we need the useEffect() hoosk.\n\n  // // we see another example just below where wo use setWatched:\n  // // setWatched([[]]); // We did setWatched here immediately in the top level code to some empty array and then actually we do get a real error. We get the error of too many re-renders. It's because of this state setting right here in setWatched(). So if we are really setting state here in the top without being inside a .then() handler, then immediately REact will complain that there are too many renders which means we again entered that infinite loop where updating the state will cause a component to re-render, which will cause the state to be set, ad so on to infinity.\n\n  // so we can useEffect() hook for above. The idea of it is to give us a place where we can safely write side effects like the above one. But side effects registered with useEffect() hook will only be excuted after certain renders(for example, only write after initial render which is exactly what we are looking for in this situation).\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(NavBar, {\n      children: [/*#__PURE__*/_jsxDEV(Search, {\n        query: query,\n        setQuery: setQuery\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(NumResults, {\n        movies: movies\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Main, {\n      children: [/*#__PURE__*/_jsxDEV(Box, {\n        children: [isLoading && /*#__PURE__*/_jsxDEV(Loader, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 181,\n          columnNumber: 25\n        }, this), !isLoading && !error && /*#__PURE__*/_jsxDEV(MovieList, {\n          movies: movies,\n          onSelectMovie: handleSelectMovie\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 183,\n          columnNumber: 13\n        }, this), error && /*#__PURE__*/_jsxDEV(ErrorMessage, {\n          message: error\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 185,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Box, {\n        children: selectedId ? /*#__PURE__*/_jsxDEV(MovieDetails, {\n          selectedId: selectedId,\n          onCloseMovie: handleCloseMovie\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 190,\n          columnNumber: 13\n        }, this) // based on selectedId, we display the movie details on the right box of screen\n        : /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(WatchedSummary, {\n            watched: watched\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 196,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(WatchedMoviesList, {\n            watched: watched\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 197,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true) // if no selectedId is false, i.e. there os no selected movie, we display this React Fragment\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 188,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(App, \"myZkOD4LVo7tCWym2oTNSxyD+TM=\");\n_c = App;\nfunction Loader() {\n  return /*#__PURE__*/_jsxDEV(\"p\", {\n    className: \"loader\",\n    children: \"Loading...\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 207,\n    columnNumber: 10\n  }, this);\n}\n_c2 = Loader;\nfunction ErrorMessage(_ref) {\n  let {\n    message\n  } = _ref;\n  return /*#__PURE__*/_jsxDEV(\"p\", {\n    className: \"error\",\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      children: \"\\u26D4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 7\n    }, this), \" \", message]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 212,\n    columnNumber: 5\n  }, this);\n}\n_c3 = ErrorMessage;\nfunction NavBar(_ref2) {\n  let {\n    children\n  } = _ref2;\n  return /*#__PURE__*/_jsxDEV(\"nav\", {\n    className: \"nav-bar\",\n    children: [/*#__PURE__*/_jsxDEV(Logo, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 221,\n      columnNumber: 7\n    }, this), children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 220,\n    columnNumber: 5\n  }, this);\n}\n_c4 = NavBar;\nfunction Logo() {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"logo\",\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      role: \"img\",\n      children: \"\\uD83C\\uDF7F\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 230,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"usePopcorn\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 229,\n    columnNumber: 5\n  }, this);\n}\n_c5 = Logo;\nfunction Search(_ref3) {\n  let {\n    query,\n    setQuery\n  } = _ref3;\n  // const [query, setQuery] = useState(\"\");\n\n  return /*#__PURE__*/_jsxDEV(\"input\", {\n    className: \"search\",\n    type: \"text\",\n    placeholder: \"Search movies...\",\n    value: query,\n    onChange: e => setQuery(e.target.value)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 240,\n    columnNumber: 5\n  }, this);\n}\n_c6 = Search;\nfunction NumResults(_ref4) {\n  let {\n    movies\n  } = _ref4;\n  return /*#__PURE__*/_jsxDEV(\"p\", {\n    className: \"num-results\",\n    children: [\"Found \", /*#__PURE__*/_jsxDEV(\"strong\", {\n      children: movies.length\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 253,\n      columnNumber: 13\n    }, this), \" results\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 252,\n    columnNumber: 5\n  }, this);\n}\n_c7 = NumResults;\nfunction Main(_ref5) {\n  let {\n    children\n  } = _ref5;\n  return /*#__PURE__*/_jsxDEV(\"main\", {\n    className: \"main\",\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 259,\n    columnNumber: 10\n  }, this);\n}\n_c8 = Main;\nfunction Box(_ref6) {\n  _s2();\n  let {\n    children\n  } = _ref6;\n  // instead of using children prop to solve prop drilling, we can also use an explicit pro\n  // (like element we used here instead of children)\n\n  const [isOpen, setIsOpen] = useState(true);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"box\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"btn-toggle\",\n      onClick: () => setIsOpen(open => !open),\n      children: isOpen ? \"–\" : \"+\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 270,\n      columnNumber: 7\n    }, this), isOpen && children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 269,\n    columnNumber: 5\n  }, this);\n}\n\n/*\nfunction WatchedBox() {\n  const [watched, setWatched] = useState(tempWatchedData);\n  const [isOpen2, setIsOpen2] = useState(true);\n\n  return (\n    <div className=\"box\">\n      <button\n        className=\"btn-toggle\"\n        onClick={() => setIsOpen2((open) => !open)}\n      >\n        {isOpen2 ? \"–\" : \"+\"}\n      </button>\n      {isOpen2 && (\n        <>\n          <WatchedSummary watched={watched} />\n          <WatchedMoviesList watched={watched} />\n        </>\n      )}\n    </div>\n  );\n}\n*/\n_s2(Box, \"mEi83NlPXQzy/XIDfTYWzOSvaHw=\");\n_c9 = Box;\nfunction MovieList(_ref7) {\n  let {\n    movies,\n    onSelectMovie\n  } = _ref7;\n  // const [movies, setMovies] = useState(tempMovieData); // we need this state to\n  //                               dynamically calculate search results found for displaying\n  //                               in NumResults component and the state lives here in this\n  //                               MovieList component so we lift this movies state up from\n  //                               here to the common parent component which is App component\n  //                               and from there pass the movies state as prop to the Main\n  //                               component and then to the ListBox component and then to\n  //                               this MovieList component and from the App component we\n  //                               also send the movies state down to Navbar component and\n  //                               then to NumResults component inside which we dynamically\n  //                               display the Number of Search results by doing\n  //                               movies.length through prop drilling. This prop drilling\n  //                               can be tedious if components are very deeply nested then\n  //                               we have to pass the prop through a lot of components. A\n  //                               solution of this problem of prop drilling is Component\n  //                               Composition. Component composition is combining\n  //                               different components using the children prop or\n  //                               explicitly defined props. Ex as just below:\n  //\n  //                               function Modal({ children }){\n  //                                 return (\n  //                                   <div className=\"modal\">\n  //                                     {children}\n  //                                   >/div>\n  //                                 )\n  //                               }\n  //\n  //                               function Error() {\n  //                                 return <p>This went wrong!</p>\n  //                               }\n  //\n  //                               Now with Component composition we can simply do:\n  //                               <Modal>\n  //                                 <Error />\n  //                               </Modal>\n  //\n  //                               We can use component composition:\n  //                               1. When we want to create highly reusable and\n  //                                  flexible components (such as the modal window)\n  //                               2. To fix prop drilling problem (great for layouts)\n  //\n  //                               Now we use component composition to fix component\n  //                               drilling problem where we pass movies prop into the\n  //                               NavBar component and then from there into the\n  //                               NumResults component. Here we only have one leve of prop\n  //                               drilling. If we could use NumResults component right in\n  //                               the App component instead of the NavBar component, then\n  //                               we wouldn't have to pass the movies prop into the NavBar\n  //                               which will fix that prop drilling problem. So we do this\n  //                               with component composition as above. So we pass children\n  //                               prop in the NavBar component function and inside it, write\n  //                               {children} in the returned <nav></nav> element after the\n  //                               <Logo/> component and in the App component, instead of\n  //                               just <Navbar/> we write it like an HTML element and inside\n  //                               it write <Search/> and <NumResults/> as:\n  //\n  //                               <NavBar>\n  //                                 <Search />\n  //                                 <NumResults movies={movies} />\n  //                               </NavBar>\n  //\n  //                               Similarly we do for <Main/> component and for any further\n  //                               component if needed\n  return /*#__PURE__*/_jsxDEV(\"ul\", {\n    className: \"list list-movies\",\n    children: movies === null || movies === void 0 ? void 0 : movies.map(movie => /*#__PURE__*/_jsxDEV(Movie, {\n      movie: movie,\n      onSelectMovie: onSelectMovie\n    }, movie.imdbID, false, {\n      fileName: _jsxFileName,\n      lineNumber: 369,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 367,\n    columnNumber: 5\n  }, this);\n}\n_c10 = MovieList;\nfunction Movie(_ref8) {\n  let {\n    movie,\n    onSelectMovie\n  } = _ref8;\n  return /*#__PURE__*/_jsxDEV(\"li\", {\n    onClick: () => onSelectMovie(movie.imdbID),\n    children: [/*#__PURE__*/_jsxDEV(\"img\", {\n      src: movie.Poster,\n      alt: `${movie.Title} poster`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 378,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: movie.Title\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 379,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\uD83D\\uDDD3\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 382,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: movie.Year\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 383,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 381,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 380,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 377,\n    columnNumber: 5\n  }, this);\n}\n_c11 = Movie;\nfunction MovieDetails(_ref9) {\n  _s3();\n  let {\n    selectedId,\n    onCloseMovie\n  } = _ref9;\n  // whenever this MovieDetails component mounts, we want to fetch the movie corresponding to the selected ID. We want to do that each time the componetn mounts, so that means we will want to use a useEffect() hook\n\n  useEffect(function () {\n    async function getMovieDetails() {\n      const res = await fetch(`https://www/omdbapi.com/?apikey=${KEY}&s=${query}`);\n    }\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"detail\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"btn-back\",\n      onClick: onCloseMovie,\n      children: \"\\u2190\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 403,\n      columnNumber: 7\n    }, this), selectedId]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 402,\n    columnNumber: 5\n  }, this);\n}\n_s3(MovieDetails, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c12 = MovieDetails;\nfunction WatchedSummary(_ref10) {\n  let {\n    watched\n  } = _ref10;\n  const avgImdbRating = average(watched.map(movie => movie.imdbRating));\n  const avgUserRating = average(watched.map(movie => movie.userRating));\n  const avgRuntime = average(watched.map(movie => movie.runtime));\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"summary\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Movies you watched\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 418,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"#\\uFE0F\\u20E3\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 421,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [watched.length, \" movies\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 422,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 420,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u2B50\\uFE0F\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 425,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: avgImdbRating\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 426,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 424,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\uD83C\\uDF1F\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 429,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: avgUserRating\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 430,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u23F3\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 433,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [avgRuntime, \" min\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 434,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 432,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 419,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 417,\n    columnNumber: 5\n  }, this);\n}\n_c13 = WatchedSummary;\nfunction WatchedMoviesList(_ref11) {\n  let {\n    watched\n  } = _ref11;\n  return /*#__PURE__*/_jsxDEV(\"ul\", {\n    className: \"list\",\n    children: watched.map(movie => /*#__PURE__*/_jsxDEV(WatchedMovie, {\n      movie: movie\n    }, movie.imdbID, false, {\n      fileName: _jsxFileName,\n      lineNumber: 445,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 443,\n    columnNumber: 5\n  }, this);\n}\n_c14 = WatchedMoviesList;\nfunction WatchedMovie(_ref12) {\n  let {\n    movie\n  } = _ref12;\n  return /*#__PURE__*/_jsxDEV(\"li\", {\n    children: [/*#__PURE__*/_jsxDEV(\"img\", {\n      src: movie.Poster,\n      alt: `${movie.Title} poster`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 454,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n      children: movie.Title\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 455,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u2B50\\uFE0F\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 458,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: movie.imdbRating\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 459,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 457,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\uD83C\\uDF1F\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 462,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: movie.userRating\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 463,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 461,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u23F3\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 466,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [movie.runtime, \" min\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 467,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 465,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 456,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 453,\n    columnNumber: 5\n  }, this);\n}\n_c15 = WatchedMovie;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15;\n$RefreshReg$(_c, \"App\");\n$RefreshReg$(_c2, \"Loader\");\n$RefreshReg$(_c3, \"ErrorMessage\");\n$RefreshReg$(_c4, \"NavBar\");\n$RefreshReg$(_c5, \"Logo\");\n$RefreshReg$(_c6, \"Search\");\n$RefreshReg$(_c7, \"NumResults\");\n$RefreshReg$(_c8, \"Main\");\n$RefreshReg$(_c9, \"Box\");\n$RefreshReg$(_c10, \"MovieList\");\n$RefreshReg$(_c11, \"Movie\");\n$RefreshReg$(_c12, \"MovieDetails\");\n$RefreshReg$(_c13, \"WatchedSummary\");\n$RefreshReg$(_c14, \"WatchedMoviesList\");\n$RefreshReg$(_c15, \"WatchedMovie\");","map":{"version":3,"names":["useEffect","useState","jsxDEV","_jsxDEV","Fragment","_Fragment","tempMovieData","imdbID","Title","Year","Poster","tempWatchedData","runtime","imdbRating","userRating","average","arr","reduce","acc","cur","i","length","KEY","App","_s","query","setQuery","movies","setMovies","watched","setWatched","isLoading","setIsLoading","error","setError","selectedId","setSelectedId","handleSelectMovie","id","handleCloseMovie","fetchMovies","res","fetch","ok","Error","data","json","Response","Search","err","console","message","children","NavBar","fileName","_jsxFileName","lineNumber","columnNumber","NumResults","Main","Box","Loader","MovieList","onSelectMovie","ErrorMessage","MovieDetails","onCloseMovie","WatchedSummary","WatchedMoviesList","_c","className","_c2","_ref","_c3","_ref2","Logo","_c4","role","_c5","_ref3","type","placeholder","value","onChange","e","target","_c6","_ref4","_c7","_ref5","_c8","_ref6","_s2","isOpen","setIsOpen","onClick","open","_c9","_ref7","map","movie","Movie","_c10","_ref8","src","alt","_c11","_ref9","_s3","getMovieDetails","_c12","_ref10","avgImdbRating","avgUserRating","avgRuntime","_c13","_ref11","WatchedMovie","_c14","_ref12","_c15","$RefreshReg$"],"sources":["C:/Users/verma/OneDrive/Desktop/Web Dev Adv/React/React/07-usepopcorn/starter/src/App.js"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nconst tempMovieData = [\n  {\n    imdbID: \"tt1375666\",\n    Title: \"Inception\",\n    Year: \"2010\",\n    Poster:\n      \"https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg\",\n  },\n  {\n    imdbID: \"tt0133093\",\n    Title: \"The Matrix\",\n    Year: \"1999\",\n    Poster:\n      \"https://m.media-amazon.com/images/M/MV5BNzQzOTk3OTAtNDQ0Zi00ZTVkLWI0MTEtMDllZjNkYzNjNTc4L2ltYWdlXkEyXkFqcGdeQXVyNjU0OTQ0OTY@._V1_SX300.jpg\",\n  },\n  {\n    imdbID: \"tt6751668\",\n    Title: \"Parasite\",\n    Year: \"2019\",\n    Poster:\n      \"https://m.media-amazon.com/images/M/MV5BYWZjMjk3ZTItODQ2ZC00NTY5LWE0ZDYtZTI3MjcwN2Q5NTVkXkEyXkFqcGdeQXVyODk4OTc3MTY@._V1_SX300.jpg\",\n  },\n];\n\nconst tempWatchedData = [\n  {\n    imdbID: \"tt1375666\",\n    Title: \"Inception\",\n    Year: \"2010\",\n    Poster:\n      \"https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg\",\n    runtime: 148,\n    imdbRating: 8.8,\n    userRating: 10,\n  },\n  {\n    imdbID: \"tt0088763\",\n    Title: \"Back to the Future\",\n    Year: \"1985\",\n    Poster:\n      \"https://m.media-amazon.com/images/M/MV5BZmU0M2Y1OGUtZjIxNi00ZjBkLTg1MjgtOWIyNThiZWIwYjRiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg\",\n    runtime: 116,\n    imdbRating: 8.5,\n    userRating: 9,\n  },\n];\n\nconst average = (arr) =>\n  arr.reduce((acc, cur, i, arr) => acc + cur / arr.length, 0);\n\nconst KEY = \"f608407f\";\n\nexport default function App() {\n  const [query, setQuery] = useState(\"\");\n  const [movies, setMovies] = useState([]);\n  const [watched, setWatched] = useState([]);\n  const [isLoading, setIsLoading] = useState(false); // now whenever movie data is still being loaded in the background, we want to instead display some loading indicator. So in case movie data loading takes time, we see a flash where there is no content. So the movie data was loading but hadn't arrived yet. So now in the mean time we want to display some loading indicator. So in order to do that we have this state which tells UI that data is still being loaded and then as soon as the data has been loaded, we want to display that data and not that indicator anymore. In our effect, right before the fetching actually starts, we setIsLoading to true.\n  const [error, setError] = useState(\"\"); // we want to display the new error message that we throw below in case an error happens while fetching data, onto the screen instead of the Loading indicator. So this state is for that. It tells currently whether we have an error or not. Here it not a boolean but truly the error message. Based on this error state, we will conditionally render the ErrorMessage component which receives a messgae prop with some message that it will then display on the screen.\n  const [selectedId, setSelectedId] = useState(null); // we need to select a movie and display some data related to it. Selecting happens on left box on dcreena nd displaying happens on right box on screen. So we create this state here in the parent component. Here we only store the id and not the entire movie object itself because the movies that we get here from the search very limited(we only get data about the title, year and the poster). On the right side we will want all kinds of details that are not included in the first search. So there would have to be another API call which will load the movie again and then we will get all the details and this movie will be fetched based on the ID that we get in the array we get when we search a movie(we can see this array by doing console.log(data.Search))\n\n  // const tempQuery = \"interstellar\";\n\n  /*\n  // BELOW IS JUST AND EXPERIMENT WITH DEPENDENCY ARRAY OF EFFECT:\n  // useEffect(function () {\n  //   console.log(\"After initial render\");\n  // }, []);\n\n  // useEffect(function () {\n  //   console.log(\"After every render\");\n  // });\n\n  // console.log(\"During render\"); // we can see that on console, first During render is logged, then After initial render, then After every render. the reason is that effects only run after the Browser paint while the render logic runs during render. So console.log(\"During render\") is executed first(so during the render of this component) and then we have After initial render and then After every render simply because After initial render appears first in the code. After it if we type any letter in the Search bar, we update the query state and hence the component is re-renered and hence consolelog(\"During render\") was executed due to which we see During render first and then After every render because the effect that logs After every render has no dependency array which means that effect is synchronized with everything and therefore it runs on every render. The effect that logs After initial render is synchronized with no variables(which is the meaning of the empty array) and therefore that effect was not executed as the component was re-rendered with the query state.\n\n  // BELOW IS ANOTHER EXPERIMENT WITH DEPENDENCY ARRAY OF EFFECT:\n  // useEffect(function () {\n  //   console.log(\"After initial render\");\n  // }, []);\n\n  // useEffect(function () {\n  //   console.log(\"After every render\");\n  // });\n\n  // useEffect(\n  //   function () {\n  //     console.log(\"D\");\n  //   },\n  //   [query]\n  // );\n\n  // console.log(\"During render\"); // now, once we type a letter in search bar, first During render is logged, then After every render and then D. Now we get D logged because then effect logging it is synchronized with the query state variable. Therefore the query just changed and the effect synchronized with state was executed and logged D.\n*/\n\n  function handleSelectMovie(id) {\n    setSelectedId((selectedId) => (id === selectedId ? null : id)); // if we click on the same movie on left box on screen as is open on right box, we want to close movie on right box and if we select a movie different from the one open on right box then we want to open that movie on the right box\n  }\n\n  function handleCloseMovie() {\n    setSelectedId(null);\n  }\n\n  // At times of fetching data and dealing with asynchronous data, we need to assume that somethings can go wrong(like internet connection breaking while fetching data or no movie found for the search query) and therefore we also need to account for those situations by handling those errors.\n  useEffect(\n    function () {\n      async function fetchMovies() {\n        try {\n          setIsLoading(true); // this tells UI that loadind is happening and we can then render the indicator over there. Then after everything is finished, we set isLoading state back to false as seen towards the end in the finally{} block in this function\n          setError(\"\"); // before we start fetching we also set the error to an empty string because if we do not do this and if we get an error at some point and we generate an error message on the screen(login for catching and setting error done below), then the next time we try to fetch data and display on screen, fetching will be done correctly(if no error occurs) but displaying cannot be done and still error is displayed on screen because we we never reset the error.\n\n          const res = await fetch(\n            `http://www.omdbapi.com/?apiKey=${KEY}&s=${query}`\n          );\n\n          if (!res.ok)\n            throw new Error(\"Something went wrong with fetching movies!\"); // now in between fetching data, user's internet connection might break so app will always keep showing the Loading indicator making user beleive that data will arrive at some point. so when it happens we want to display an error message on screen. Now reacting to errors like this is not built into the fetch() function itself, we need to do it manually. Now here on the response object that we receive from the fetch() exists one ok property. So basically if the response is not ok, then we want to throw a new error. Now if we throw an error here, we need to wrap all our code into a try catch block.\n\n          const data = await res.json();\n          // console.log(data);\n\n          if (data.Response === \"False\") throw new Error(\"Movie not found !\"); // if for a query, no movie is found, then the data that comes back from this API is undefined. So we no longer have the Search property now(So we don't have data.Search). So what happens is that data.Search is being set to undefined. So now if we log the received data on cosole, we see an object with Response and Error properties. So we can use Response(which in this case is False) to check if the movie is not found and throw an Error. This if here and not anywhere else because we check it after we have received the data from API.\n\n          setMovies(data.Search);\n          // console.log(movies); // here if we try to log the movies to the console, we get an empty array as a result. This happens becuase setting state is asynchronous. So after setting state in the just above line using setMovies(), it doesn't mean that it happens immediately. So it will happen after the function has been called. so right here in console.log(movies), we have stale state. So before, movies was just an empty array which gets logged. After some time we get the correct output. Now if we do this console.log() again, we get correct output. Now, the reson for getting two outputs is because of React's strict mode. So when strict mode is active in React 18, our effects will run not only once, but twice(but only in development. So when our application is in production, this will no longer be happening). This happens so REact can identify if there are some problems in our effects.\n        } catch (err) {\n          console.error(err.message); // err.message is the string that pass into throw new Error('') as above.\n          setError(err.message); // in case of error, we set the error state to the error string that we passed above while throwing error. Now based on this error state, we will conditionally render the ErrorMessage component which receives a messgae prop with some message that it will then display on the screen.\n        } finally {\n          setIsLoading(false); // This is here because is we the error is thrown above, then the code after it in the try{} block will not be executed. So it is in this finally{} block which is always executed. Now in the returned JSX, we conditionally render the <Loader.> component if isLoading is true, but there are 2 more conditional renders with it. (Look and understand. if not understood, Watch Lecture 146 - Adding a loading state and Lecture 147 - Handling errors)\n        }\n      }\n\n      if (!query.length) {\n        setMovies([]); // here we set movies back to an empty array(so basically removing all the movies from the UI)\n        setError(\"\"); // here we reset the error back to nothing\n        return;\n      } // if we don't do this if if block, then when have no search query, we see Movie not found on screen(even on opening application) which is not really true(It is actually true because the API actually searched for a movie with an empty string but in a situation when we have no query we actually don't even want to search). Also, doing this if block, the fetchMovies function will not even be called(as called in the just below line).\n\n      fetchMovies(); // here we just call the function\n    },\n    [query]\n  ); // useEffects() doesn't return anything so we don't store the resuukt into any variable but instead we pass in a function and this function is then called our effect and it contains the code that we want to run as a side effect(so basically that we want to register as a side effect to be executed at a certain point in time). We also need to pass in a second argumnent which is a dependency array. We'll learn about it as we proceed further. empty array as here means that the effect that we just specified here will only run on mount. Now ew can see that there are no infinite loops or requests. So now effect is only running as the component mounts. Now, whenever we need a lot of code to handle a promise, it's a lot easier and nicer to just have an async function. However if we write async nefore the function inside useEffect() here and use await inside it, we get an ESLint warning which tells us that effect callbacks are synchronous to prevent race conditions. So basically the effect function that we placed into useEffect() cannot return a promise which is what an async function does. So instead of doing diretly like this, we create a new function and place the async function there as we did here\n\n  // // We know we should never update state in render logic.\n  // // Basic idea is to fetch some movie data as soon as this App component here mounts for the very  first time.\n  // fetch(`http://www.omdbapi.com/?apiKey=${KEY}&s=interstellar`)\n  //   .then((res) => res.json())\n  //   .then((data) => console.log(data.Search)); // Now, this data fetching that we are doing here is actually introducing a side effect into the component's render logic. So it is clearly an interaction with an outside world which should never be allowed in render logic. Now, as we see here, if insetead of logging the fetched data on console, we set state here with the fetched data, in the Network tab we can see that it is running an infinite number of requests and it never really stops. So every second, our app is firing off multiple requests to this API. This happends because setting the state here in the render logic will then immediately cause the component to re-render itself again. However, as the component is re-rendered, the function here is executed again, which in turn will fetch again, which in turn will set the movies again as well and this whole thing starts over ad over again. So this is the reason why it is really not allowed to set state in the render logic. Now, we do actually need to set the movies here but without all the problems. So for that we need the useEffect() hoosk.\n\n  // // we see another example just below where wo use setWatched:\n  // // setWatched([[]]); // We did setWatched here immediately in the top level code to some empty array and then actually we do get a real error. We get the error of too many re-renders. It's because of this state setting right here in setWatched(). So if we are really setting state here in the top without being inside a .then() handler, then immediately REact will complain that there are too many renders which means we again entered that infinite loop where updating the state will cause a component to re-render, which will cause the state to be set, ad so on to infinity.\n\n  // so we can useEffect() hook for above. The idea of it is to give us a place where we can safely write side effects like the above one. But side effects registered with useEffect() hook will only be excuted after certain renders(for example, only write after initial render which is exactly what we are looking for in this situation).\n  return (\n    <>\n      <NavBar>\n        <Search query={query} setQuery={setQuery} />\n        <NumResults movies={movies} />\n      </NavBar>\n      <Main>\n        {/* <Box element={<MovieList movies={movies} />} />\n        <Box\n          element={\n            <>\n              <WatchedSummary watched={watched} />\n              <WatchedMoviesList watched={watched} />\n            </>\n          }\n        /> */}\n        {/* Above is prop drilling solution using explicity prop (element in this case. It\n            can be anything. So we pass element as prop instead of children in the Box\n            component and conditionally render that element prop). In the 2nd <Box />\n            component above, we are passing a brand new piece of JSX, so here now we actually\n            need a fragment */}\n\n        {/* Below is prop drilling solution using children prop */}\n\n        <Box>\n          {/* {isLoading ? <Loader /> : <MovieList movies={movies} />} */}\n          {isLoading && <Loader />}\n          {!isLoading && !error && (\n            <MovieList movies={movies} onSelectMovie={handleSelectMovie} />\n          )}\n          {error && <ErrorMessage message={error} />}\n        </Box>\n\n        <Box>\n          {selectedId ? (\n            <MovieDetails\n              selectedId={selectedId}\n              onCloseMovie={handleCloseMovie}\n            /> // based on selectedId, we display the movie details on the right box of screen\n          ) : (\n            <>\n              <WatchedSummary watched={watched} />\n              <WatchedMoviesList watched={watched} />\n            </> // if no selectedId is false, i.e. there os no selected movie, we display this React Fragment\n          )}\n        </Box>\n      </Main>\n    </>\n  );\n}\n\nfunction Loader() {\n  return <p className=\"loader\">Loading...</p>;\n}\n\nfunction ErrorMessage({ message }) {\n  return (\n    <p className=\"error\">\n      <span>⛔</span> {message}\n    </p>\n  );\n}\n\nfunction NavBar({ children }) {\n  return (\n    <nav className=\"nav-bar\">\n      <Logo />\n      {children}\n    </nav>\n  );\n}\n\nfunction Logo() {\n  return (\n    <div className=\"logo\">\n      <span role=\"img\">🍿</span>\n      <h1>usePopcorn</h1>\n    </div>\n  );\n}\n\nfunction Search({ query, setQuery }) {\n  // const [query, setQuery] = useState(\"\");\n\n  return (\n    <input\n      className=\"search\"\n      type=\"text\"\n      placeholder=\"Search movies...\"\n      value={query}\n      onChange={(e) => setQuery(e.target.value)}\n    />\n  );\n}\n\nfunction NumResults({ movies }) {\n  return (\n    <p className=\"num-results\">\n      Found <strong>{movies.length}</strong> results\n    </p>\n  );\n}\n\nfunction Main({ children }) {\n  return <main className=\"main\">{children}</main>;\n}\n\nfunction Box({ children }) {\n  // instead of using children prop to solve prop drilling, we can also use an explicit pro\n  // (like element we used here instead of children)\n\n  const [isOpen, setIsOpen] = useState(true);\n\n  return (\n    <div className=\"box\">\n      <button className=\"btn-toggle\" onClick={() => setIsOpen((open) => !open)}>\n        {isOpen ? \"–\" : \"+\"}\n      </button>\n      {isOpen && children}\n    </div>\n  );\n}\n\n/*\nfunction WatchedBox() {\n  const [watched, setWatched] = useState(tempWatchedData);\n  const [isOpen2, setIsOpen2] = useState(true);\n\n  return (\n    <div className=\"box\">\n      <button\n        className=\"btn-toggle\"\n        onClick={() => setIsOpen2((open) => !open)}\n      >\n        {isOpen2 ? \"–\" : \"+\"}\n      </button>\n      {isOpen2 && (\n        <>\n          <WatchedSummary watched={watched} />\n          <WatchedMoviesList watched={watched} />\n        </>\n      )}\n    </div>\n  );\n}\n*/\n\nfunction MovieList({ movies, onSelectMovie }) {\n  // const [movies, setMovies] = useState(tempMovieData); // we need this state to\n  //                               dynamically calculate search results found for displaying\n  //                               in NumResults component and the state lives here in this\n  //                               MovieList component so we lift this movies state up from\n  //                               here to the common parent component which is App component\n  //                               and from there pass the movies state as prop to the Main\n  //                               component and then to the ListBox component and then to\n  //                               this MovieList component and from the App component we\n  //                               also send the movies state down to Navbar component and\n  //                               then to NumResults component inside which we dynamically\n  //                               display the Number of Search results by doing\n  //                               movies.length through prop drilling. This prop drilling\n  //                               can be tedious if components are very deeply nested then\n  //                               we have to pass the prop through a lot of components. A\n  //                               solution of this problem of prop drilling is Component\n  //                               Composition. Component composition is combining\n  //                               different components using the children prop or\n  //                               explicitly defined props. Ex as just below:\n  //\n  //                               function Modal({ children }){\n  //                                 return (\n  //                                   <div className=\"modal\">\n  //                                     {children}\n  //                                   >/div>\n  //                                 )\n  //                               }\n  //\n  //                               function Error() {\n  //                                 return <p>This went wrong!</p>\n  //                               }\n  //\n  //                               Now with Component composition we can simply do:\n  //                               <Modal>\n  //                                 <Error />\n  //                               </Modal>\n  //\n  //                               We can use component composition:\n  //                               1. When we want to create highly reusable and\n  //                                  flexible components (such as the modal window)\n  //                               2. To fix prop drilling problem (great for layouts)\n  //\n  //                               Now we use component composition to fix component\n  //                               drilling problem where we pass movies prop into the\n  //                               NavBar component and then from there into the\n  //                               NumResults component. Here we only have one leve of prop\n  //                               drilling. If we could use NumResults component right in\n  //                               the App component instead of the NavBar component, then\n  //                               we wouldn't have to pass the movies prop into the NavBar\n  //                               which will fix that prop drilling problem. So we do this\n  //                               with component composition as above. So we pass children\n  //                               prop in the NavBar component function and inside it, write\n  //                               {children} in the returned <nav></nav> element after the\n  //                               <Logo/> component and in the App component, instead of\n  //                               just <Navbar/> we write it like an HTML element and inside\n  //                               it write <Search/> and <NumResults/> as:\n  //\n  //                               <NavBar>\n  //                                 <Search />\n  //                                 <NumResults movies={movies} />\n  //                               </NavBar>\n  //\n  //                               Similarly we do for <Main/> component and for any further\n  //                               component if needed\n  return (\n    <ul className=\"list list-movies\">\n      {movies?.map((movie) => (\n        <Movie movie={movie} key={movie.imdbID} onSelectMovie={onSelectMovie} />\n      ))}\n    </ul>\n  );\n}\n\nfunction Movie({ movie, onSelectMovie }) {\n  return (\n    <li onClick={() => onSelectMovie(movie.imdbID)}>\n      <img src={movie.Poster} alt={`${movie.Title} poster`} />\n      <h3>{movie.Title}</h3>\n      <div>\n        <p>\n          <span>🗓</span>\n          <span>{movie.Year}</span>\n        </p>\n      </div>\n    </li>\n  );\n}\n\nfunction MovieDetails({ selectedId, onCloseMovie }) {\n  // whenever this MovieDetails component mounts, we want to fetch the movie corresponding to the selected ID. We want to do that each time the componetn mounts, so that means we will want to use a useEffect() hook\n\n  useEffect(function () {\n    async function getMovieDetails() {\n      const res = await fetch(\n        `https://www/omdbapi.com/?apikey=${KEY}&s=${query}`\n      );\n    }\n  }, []);\n\n  return (\n    <div className=\"detail\">\n      <button className=\"btn-back\" onClick={onCloseMovie}>\n        &larr;\n      </button>\n      {selectedId}\n    </div>\n  );\n}\n\nfunction WatchedSummary({ watched }) {\n  const avgImdbRating = average(watched.map((movie) => movie.imdbRating));\n  const avgUserRating = average(watched.map((movie) => movie.userRating));\n  const avgRuntime = average(watched.map((movie) => movie.runtime));\n\n  return (\n    <div className=\"summary\">\n      <h2>Movies you watched</h2>\n      <div>\n        <p>\n          <span>#️⃣</span>\n          <span>{watched.length} movies</span>\n        </p>\n        <p>\n          <span>⭐️</span>\n          <span>{avgImdbRating}</span>\n        </p>\n        <p>\n          <span>🌟</span>\n          <span>{avgUserRating}</span>\n        </p>\n        <p>\n          <span>⏳</span>\n          <span>{avgRuntime} min</span>\n        </p>\n      </div>\n    </div>\n  );\n}\n\nfunction WatchedMoviesList({ watched }) {\n  return (\n    <ul className=\"list\">\n      {watched.map((movie) => (\n        <WatchedMovie movie={movie} key={movie.imdbID} />\n      ))}\n    </ul>\n  );\n}\n\nfunction WatchedMovie({ movie }) {\n  return (\n    <li>\n      <img src={movie.Poster} alt={`${movie.Title} poster`} />\n      <h3>{movie.Title}</h3>\n      <div>\n        <p>\n          <span>⭐️</span>\n          <span>{movie.imdbRating}</span>\n        </p>\n        <p>\n          <span>🌟</span>\n          <span>{movie.userRating}</span>\n        </p>\n        <p>\n          <span>⏳</span>\n          <span>{movie.runtime} min</span>\n        </p>\n      </div>\n    </li>\n  );\n}\n"],"mappings":";;;;AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAAA,SAAAC,QAAA,IAAAC,SAAA;AAE5C,MAAMC,aAAa,GAAG,CACpB;EACEC,MAAM,EAAE,WAAW;EACnBC,KAAK,EAAE,WAAW;EAClBC,IAAI,EAAE,MAAM;EACZC,MAAM,EACJ;AACJ,CAAC,EACD;EACEH,MAAM,EAAE,WAAW;EACnBC,KAAK,EAAE,YAAY;EACnBC,IAAI,EAAE,MAAM;EACZC,MAAM,EACJ;AACJ,CAAC,EACD;EACEH,MAAM,EAAE,WAAW;EACnBC,KAAK,EAAE,UAAU;EACjBC,IAAI,EAAE,MAAM;EACZC,MAAM,EACJ;AACJ,CAAC,CACF;AAED,MAAMC,eAAe,GAAG,CACtB;EACEJ,MAAM,EAAE,WAAW;EACnBC,KAAK,EAAE,WAAW;EAClBC,IAAI,EAAE,MAAM;EACZC,MAAM,EACJ,oGAAoG;EACtGE,OAAO,EAAE,GAAG;EACZC,UAAU,EAAE,GAAG;EACfC,UAAU,EAAE;AACd,CAAC,EACD;EACEP,MAAM,EAAE,WAAW;EACnBC,KAAK,EAAE,oBAAoB;EAC3BC,IAAI,EAAE,MAAM;EACZC,MAAM,EACJ,oIAAoI;EACtIE,OAAO,EAAE,GAAG;EACZC,UAAU,EAAE,GAAG;EACfC,UAAU,EAAE;AACd,CAAC,CACF;AAED,MAAMC,OAAO,GAAIC,GAAG,IAClBA,GAAG,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,EAAEC,CAAC,EAAEJ,GAAG,KAAKE,GAAG,GAAGC,GAAG,GAAGH,GAAG,CAACK,MAAM,EAAE,CAAC,CAAC;AAE7D,MAAMC,GAAG,GAAG,UAAU;AAEtB,eAAe,SAASC,GAAGA,CAAA,EAAG;EAAAC,EAAA;EAC5B,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGzB,QAAQ,CAAC,EAAE,CAAC;EACtC,MAAM,CAAC0B,MAAM,EAAEC,SAAS,CAAC,GAAG3B,QAAQ,CAAC,EAAE,CAAC;EACxC,MAAM,CAAC4B,OAAO,EAAEC,UAAU,CAAC,GAAG7B,QAAQ,CAAC,EAAE,CAAC;EAC1C,MAAM,CAAC8B,SAAS,EAAEC,YAAY,CAAC,GAAG/B,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;EACnD,MAAM,CAACgC,KAAK,EAAEC,QAAQ,CAAC,GAAGjC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;EACxC,MAAM,CAACkC,UAAU,EAAEC,aAAa,CAAC,GAAGnC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;;EAEpD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAQE,SAASoC,iBAAiBA,CAACC,EAAE,EAAE;IAC7BF,aAAa,CAAED,UAAU,IAAMG,EAAE,KAAKH,UAAU,GAAG,IAAI,GAAGG,EAAG,CAAC,CAAC,CAAC;EAClE;;EAEA,SAASC,gBAAgBA,CAAA,EAAG;IAC1BH,aAAa,CAAC,IAAI,CAAC;EACrB;;EAEA;EACApC,SAAS,CACP,YAAY;IACV,eAAewC,WAAWA,CAAA,EAAG;MAC3B,IAAI;QACFR,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QACpBE,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;;QAEd,MAAMO,GAAG,GAAG,MAAMC,KAAK,CACpB,kCAAiCpB,GAAI,MAAKG,KAAM,EAAC,CACnD;QAED,IAAI,CAACgB,GAAG,CAACE,EAAE,EACT,MAAM,IAAIC,KAAK,CAAC,4CAA4C,CAAC,CAAC,CAAC;;QAEjE,MAAMC,IAAI,GAAG,MAAMJ,GAAG,CAACK,IAAI,EAAE;QAC7B;;QAEA,IAAID,IAAI,CAACE,QAAQ,KAAK,OAAO,EAAE,MAAM,IAAIH,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;;QAErEhB,SAAS,CAACiB,IAAI,CAACG,MAAM,CAAC;QACtB;MACF,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZC,OAAO,CAACjB,KAAK,CAACgB,GAAG,CAACE,OAAO,CAAC,CAAC,CAAC;QAC5BjB,QAAQ,CAACe,GAAG,CAACE,OAAO,CAAC,CAAC,CAAC;MACzB,CAAC,SAAS;QACRnB,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;MACvB;IACF;;IAEA,IAAI,CAACP,KAAK,CAACJ,MAAM,EAAE;MACjBO,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;MACfM,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;MACd;IACF,CAAC,CAAC;;IAEFM,WAAW,EAAE,CAAC,CAAC;EACjB,CAAC,EACD,CAACf,KAAK,CAAC,CACR,CAAC,CAAC;;EAEH;EACA;EACA;EACA;EACA;;EAEA;EACA;;EAEA;EACA,oBACEtB,OAAA,CAAAE,SAAA;IAAA+C,QAAA,gBACEjD,OAAA,CAACkD,MAAM;MAAAD,QAAA,gBACLjD,OAAA,CAAC6C,MAAM;QAACvB,KAAK,EAAEA,KAAM;QAACC,QAAQ,EAAEA;MAAS;QAAA4B,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAG,eAC5CtD,OAAA,CAACuD,UAAU;QAAC/B,MAAM,EAAEA;MAAO;QAAA2B,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAG;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACvB,eACTtD,OAAA,CAACwD,IAAI;MAAAP,QAAA,gBAkBHjD,OAAA,CAACyD,GAAG;QAAAR,QAAA,GAEDrB,SAAS,iBAAI5B,OAAA,CAAC0D,MAAM;UAAAP,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAG,EACvB,CAAC1B,SAAS,IAAI,CAACE,KAAK,iBACnB9B,OAAA,CAAC2D,SAAS;UAACnC,MAAM,EAAEA,MAAO;UAACoC,aAAa,EAAE1B;QAAkB;UAAAiB,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAC7D,EACAxB,KAAK,iBAAI9B,OAAA,CAAC6D,YAAY;UAACb,OAAO,EAAElB;QAAM;UAAAqB,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAG;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QACtC,eAENtD,OAAA,CAACyD,GAAG;QAAAR,QAAA,EACDjB,UAAU,gBACThC,OAAA,CAAC8D,YAAY;UACX9B,UAAU,EAAEA,UAAW;UACvB+B,YAAY,EAAE3B;QAAiB;UAAAe,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAC/B,CAAC;QAAA,eAEHtD,OAAA,CAAAE,SAAA;UAAA+C,QAAA,gBACEjD,OAAA,CAACgE,cAAc;YAACtC,OAAO,EAAEA;UAAQ;YAAAyB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,QAAG,eACpCtD,OAAA,CAACiE,iBAAiB;YAACvC,OAAO,EAAEA;UAAQ;YAAAyB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,QAAG;QAAA,gBACtC,CAAC;MACL;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QACG;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACD;EAAA,gBACN;AAEP;AAACjC,EAAA,CArJuBD,GAAG;AAAA8C,EAAA,GAAH9C,GAAG;AAuJ3B,SAASsC,MAAMA,CAAA,EAAG;EAChB,oBAAO1D,OAAA;IAAGmE,SAAS,EAAC,QAAQ;IAAAlB,QAAA,EAAC;EAAU;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QAAI;AAC7C;AAACc,GAAA,GAFQV,MAAM;AAIf,SAASG,YAAYA,CAAAQ,IAAA,EAAc;EAAA,IAAb;IAAErB;EAAQ,CAAC,GAAAqB,IAAA;EAC/B,oBACErE,OAAA;IAAGmE,SAAS,EAAC,OAAO;IAAAlB,QAAA,gBAClBjD,OAAA;MAAAiD,QAAA,EAAM;IAAC;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAO,KAAC,EAACN,OAAO;EAAA;IAAAG,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACrB;AAER;AAACgB,GAAA,GANQT,YAAY;AAQrB,SAASX,MAAMA,CAAAqB,KAAA,EAAe;EAAA,IAAd;IAAEtB;EAAS,CAAC,GAAAsB,KAAA;EAC1B,oBACEvE,OAAA;IAAKmE,SAAS,EAAC,SAAS;IAAAlB,QAAA,gBACtBjD,OAAA,CAACwE,IAAI;MAAArB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAG,EACPL,QAAQ;EAAA;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACL;AAEV;AAACmB,GAAA,GAPQvB,MAAM;AASf,SAASsB,IAAIA,CAAA,EAAG;EACd,oBACExE,OAAA;IAAKmE,SAAS,EAAC,MAAM;IAAAlB,QAAA,gBACnBjD,OAAA;MAAM0E,IAAI,EAAC,KAAK;MAAAzB,QAAA,EAAC;IAAE;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAO,eAC1BtD,OAAA;MAAAiD,QAAA,EAAI;IAAU;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAK;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACf;AAEV;AAACqB,GAAA,GAPQH,IAAI;AASb,SAAS3B,MAAMA,CAAA+B,KAAA,EAAsB;EAAA,IAArB;IAAEtD,KAAK;IAAEC;EAAS,CAAC,GAAAqD,KAAA;EACjC;;EAEA,oBACE5E,OAAA;IACEmE,SAAS,EAAC,QAAQ;IAClBU,IAAI,EAAC,MAAM;IACXC,WAAW,EAAC,kBAAkB;IAC9BC,KAAK,EAAEzD,KAAM;IACb0D,QAAQ,EAAGC,CAAC,IAAK1D,QAAQ,CAAC0D,CAAC,CAACC,MAAM,CAACH,KAAK;EAAE;IAAA5B,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QAC1C;AAEN;AAAC6B,GAAA,GAZQtC,MAAM;AAcf,SAASU,UAAUA,CAAA6B,KAAA,EAAa;EAAA,IAAZ;IAAE5D;EAAO,CAAC,GAAA4D,KAAA;EAC5B,oBACEpF,OAAA;IAAGmE,SAAS,EAAC,aAAa;IAAAlB,QAAA,GAAC,QACnB,eAAAjD,OAAA;MAAAiD,QAAA,EAASzB,MAAM,CAACN;IAAM;MAAAiC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAU,YACxC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QAAI;AAER;AAAC+B,GAAA,GANQ9B,UAAU;AAQnB,SAASC,IAAIA,CAAA8B,KAAA,EAAe;EAAA,IAAd;IAAErC;EAAS,CAAC,GAAAqC,KAAA;EACxB,oBAAOtF,OAAA;IAAMmE,SAAS,EAAC,MAAM;IAAAlB,QAAA,EAAEA;EAAQ;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QAAQ;AACjD;AAACiC,GAAA,GAFQ/B,IAAI;AAIb,SAASC,GAAGA,CAAA+B,KAAA,EAAe;EAAAC,GAAA;EAAA,IAAd;IAAExC;EAAS,CAAC,GAAAuC,KAAA;EACvB;EACA;;EAEA,MAAM,CAACE,MAAM,EAAEC,SAAS,CAAC,GAAG7F,QAAQ,CAAC,IAAI,CAAC;EAE1C,oBACEE,OAAA;IAAKmE,SAAS,EAAC,KAAK;IAAAlB,QAAA,gBAClBjD,OAAA;MAAQmE,SAAS,EAAC,YAAY;MAACyB,OAAO,EAAEA,CAAA,KAAMD,SAAS,CAAEE,IAAI,IAAK,CAACA,IAAI,CAAE;MAAA5C,QAAA,EACtEyC,MAAM,GAAG,GAAG,GAAG;IAAG;MAAAvC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACZ,EACRoC,MAAM,IAAIzC,QAAQ;EAAA;IAAAE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACf;AAEV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBAmC,GAAA,CAhBShC,GAAG;AAAAqC,GAAA,GAAHrC,GAAG;AAwCZ,SAASE,SAASA,CAAAoC,KAAA,EAA4B;EAAA,IAA3B;IAAEvE,MAAM;IAAEoC;EAAc,CAAC,GAAAmC,KAAA;EAC1C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,oBACE/F,OAAA;IAAImE,SAAS,EAAC,kBAAkB;IAAAlB,QAAA,EAC7BzB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEwE,GAAG,CAAEC,KAAK,iBACjBjG,OAAA,CAACkG,KAAK;MAACD,KAAK,EAAEA,KAAM;MAAoBrC,aAAa,EAAEA;IAAc,GAA3CqC,KAAK,CAAC7F,MAAM;MAAA+C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACvC;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACC;AAET;AAAC6C,IAAA,GAvEQxC,SAAS;AAyElB,SAASuC,KAAKA,CAAAE,KAAA,EAA2B;EAAA,IAA1B;IAAEH,KAAK;IAAErC;EAAc,CAAC,GAAAwC,KAAA;EACrC,oBACEpG,OAAA;IAAI4F,OAAO,EAAEA,CAAA,KAAMhC,aAAa,CAACqC,KAAK,CAAC7F,MAAM,CAAE;IAAA6C,QAAA,gBAC7CjD,OAAA;MAAKqG,GAAG,EAAEJ,KAAK,CAAC1F,MAAO;MAAC+F,GAAG,EAAG,GAAEL,KAAK,CAAC5F,KAAM;IAAS;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAG,eACxDtD,OAAA;MAAAiD,QAAA,EAAKgD,KAAK,CAAC5F;IAAK;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAM,eACtBtD,OAAA;MAAAiD,QAAA,eACEjD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAE;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACftD,OAAA;UAAAiD,QAAA,EAAOgD,KAAK,CAAC3F;QAAI;UAAA6C,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAQ;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA;IACvB;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACA;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACH;AAET;AAACiD,IAAA,GAbQL,KAAK;AAed,SAASpC,YAAYA,CAAA0C,KAAA,EAA+B;EAAAC,GAAA;EAAA,IAA9B;IAAEzE,UAAU;IAAE+B;EAAa,CAAC,GAAAyC,KAAA;EAChD;;EAEA3G,SAAS,CAAC,YAAY;IACpB,eAAe6G,eAAeA,CAAA,EAAG;MAC/B,MAAMpE,GAAG,GAAG,MAAMC,KAAK,CACpB,mCAAkCpB,GAAI,MAAKG,KAAM,EAAC,CACpD;IACH;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,oBACEtB,OAAA;IAAKmE,SAAS,EAAC,QAAQ;IAAAlB,QAAA,gBACrBjD,OAAA;MAAQmE,SAAS,EAAC,UAAU;MAACyB,OAAO,EAAE7B,YAAa;MAAAd,QAAA,EAAC;IAEpD;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAS,EACRtB,UAAU;EAAA;IAAAmB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACP;AAEV;AAACmD,GAAA,CAnBQ3C,YAAY;AAAA6C,IAAA,GAAZ7C,YAAY;AAqBrB,SAASE,cAAcA,CAAA4C,MAAA,EAAc;EAAA,IAAb;IAAElF;EAAQ,CAAC,GAAAkF,MAAA;EACjC,MAAMC,aAAa,GAAGjG,OAAO,CAACc,OAAO,CAACsE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACvF,UAAU,CAAC,CAAC;EACvE,MAAMoG,aAAa,GAAGlG,OAAO,CAACc,OAAO,CAACsE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACtF,UAAU,CAAC,CAAC;EACvE,MAAMoG,UAAU,GAAGnG,OAAO,CAACc,OAAO,CAACsE,GAAG,CAAEC,KAAK,IAAKA,KAAK,CAACxF,OAAO,CAAC,CAAC;EAEjE,oBACET,OAAA;IAAKmE,SAAS,EAAC,SAAS;IAAAlB,QAAA,gBACtBjD,OAAA;MAAAiD,QAAA,EAAI;IAAkB;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAK,eAC3BtD,OAAA;MAAAiD,QAAA,gBACEjD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAG;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eAChBtD,OAAA;UAAAiD,QAAA,GAAOvB,OAAO,CAACR,MAAM,EAAC,SAAO;QAAA;UAAAiC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAClC,eACJtD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAE;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACftD,OAAA;UAAAiD,QAAA,EAAO4D;QAAa;UAAA1D,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAQ;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC1B,eACJtD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAE;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACftD,OAAA;UAAAiD,QAAA,EAAO6D;QAAa;UAAA3D,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAQ;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC1B,eACJtD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAC;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACdtD,OAAA;UAAAiD,QAAA,GAAO8D,UAAU,EAAC,MAAI;QAAA;UAAA5D,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC3B;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACA;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACF;AAEV;AAAC0D,IAAA,GA5BQhD,cAAc;AA8BvB,SAASC,iBAAiBA,CAAAgD,MAAA,EAAc;EAAA,IAAb;IAAEvF;EAAQ,CAAC,GAAAuF,MAAA;EACpC,oBACEjH,OAAA;IAAImE,SAAS,EAAC,MAAM;IAAAlB,QAAA,EACjBvB,OAAO,CAACsE,GAAG,CAAEC,KAAK,iBACjBjG,OAAA,CAACkH,YAAY;MAACjB,KAAK,EAAEA;IAAM,GAAMA,KAAK,CAAC7F,MAAM;MAAA+C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAC9C;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACC;AAET;AAAC6D,IAAA,GARQlD,iBAAiB;AAU1B,SAASiD,YAAYA,CAAAE,MAAA,EAAY;EAAA,IAAX;IAAEnB;EAAM,CAAC,GAAAmB,MAAA;EAC7B,oBACEpH,OAAA;IAAAiD,QAAA,gBACEjD,OAAA;MAAKqG,GAAG,EAAEJ,KAAK,CAAC1F,MAAO;MAAC+F,GAAG,EAAG,GAAEL,KAAK,CAAC5F,KAAM;IAAS;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAG,eACxDtD,OAAA;MAAAiD,QAAA,EAAKgD,KAAK,CAAC5F;IAAK;MAAA8C,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAAM,eACtBtD,OAAA;MAAAiD,QAAA,gBACEjD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAE;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACftD,OAAA;UAAAiD,QAAA,EAAOgD,KAAK,CAACvF;QAAU;UAAAyC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAQ;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC7B,eACJtD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAE;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACftD,OAAA;UAAAiD,QAAA,EAAOgD,KAAK,CAACtF;QAAU;UAAAwC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAQ;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC7B,eACJtD,OAAA;QAAAiD,QAAA,gBACEjD,OAAA;UAAAiD,QAAA,EAAM;QAAC;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO,eACdtD,OAAA;UAAAiD,QAAA,GAAOgD,KAAK,CAACxF,OAAO,EAAC,MAAI;QAAA;UAAA0C,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,QAAO;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAC9B;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QACA;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QACH;AAET;AAAC+D,IAAA,GArBQH,YAAY;AAAA,IAAAhD,EAAA,EAAAE,GAAA,EAAAE,GAAA,EAAAG,GAAA,EAAAE,GAAA,EAAAQ,GAAA,EAAAE,GAAA,EAAAE,GAAA,EAAAO,GAAA,EAAAK,IAAA,EAAAI,IAAA,EAAAI,IAAA,EAAAK,IAAA,EAAAG,IAAA,EAAAE,IAAA;AAAAC,YAAA,CAAApD,EAAA;AAAAoD,YAAA,CAAAlD,GAAA;AAAAkD,YAAA,CAAAhD,GAAA;AAAAgD,YAAA,CAAA7C,GAAA;AAAA6C,YAAA,CAAA3C,GAAA;AAAA2C,YAAA,CAAAnC,GAAA;AAAAmC,YAAA,CAAAjC,GAAA;AAAAiC,YAAA,CAAA/B,GAAA;AAAA+B,YAAA,CAAAxB,GAAA;AAAAwB,YAAA,CAAAnB,IAAA;AAAAmB,YAAA,CAAAf,IAAA;AAAAe,YAAA,CAAAX,IAAA;AAAAW,YAAA,CAAAN,IAAA;AAAAM,YAAA,CAAAH,IAAA;AAAAG,YAAA,CAAAD,IAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}